<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: terraform | Adventures of a wannabe geek!]]></title>
  <link href="http://paulstack.co.uk/blog/categories/terraform/atom.xml" rel="self"/>
  <link href="http://paulstack.co.uk/"/>
  <updated>2016-01-02T13:31:31+00:00</updated>
  <id>http://paulstack.co.uk/</id>
  <author>
    <name><![CDATA[Paul Stack (@stack72)]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Building an ElasticSearch cluster in AWS with Packer and Terraform]]></title>
    <link href="http://paulstack.co.uk/blog/2016/01/02/building-an-elasticsearch-cluster-in-aws-with-packer-and-terraform/"/>
    <updated>2016-01-02T12:47:00+00:00</updated>
    <id>http://paulstack.co.uk/blog/2016/01/02/building-an-elasticsearch-cluster-in-aws-with-packer-and-terraform</id>
    <content type="html"><![CDATA[<p>As discussed in a <a href="http://www.paulstack.co.uk/blog/2015/11/09/the-quest-for-infra-management-2-dot-0/">previous post</a>, I like to build separate <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/AMIs.html">AMIs</a> for each of my systems. This allows me to scale up and recycle nodes easily. I have been doing this with <a href="https://www.elastic.co/products/elasticsearch">ElasticSearch</a> for a while now. I usually build an AMI with <a href="https://packer.io/">Packer</a> and <a href="http://www.ansible.com/">Ansible</a> and I use <a href="https://terraform.io/">Terraform</a> to roll out the infrastructure</p>

<h3>Building ElasticSearch AMIs with Packer</h3>

<p>The packer template looks as follows:</p>

<p>```
{
  &ldquo;variables&rdquo;: {</p>

<pre><code>"ami_id": "",
"private_subnet_id": "",
"security_group_id": "",
"packer_build_number": "",
</code></pre>

<p>  },
  &ldquo;description&rdquo;: &ldquo;ElasticSearch Image&rdquo;,
  &ldquo;builders&rdquo;: [</p>

<pre><code>{
  "ami_name": "elasticsearch-",
  "availability_zone": "eu-west-1a",
  "iam_instance_profile": "app-server",
  "instance_type": "t2.small",
  "region": "eu-west-1",
  "run_tags": {
    "role": "packer"
  },
  "security_group_ids": [
    ""
  ],
  "source_ami": "",
  "ssh_timeout": "10m",
  "ssh_username": "ubuntu",
  "subnet_id": "",
  "tags": {
    "Name": "elasticsearch-packer-image"
  },
  "type": "amazon-ebs"
}
</code></pre>

<p>  ],
  &ldquo;provisioners&rdquo;: [</p>

<pre><code>{
  "type": "shell",
  "inline": [ "sleep 10" ]
},
{
  "type": "shell",
  "script": "install_dependencies.sh",
  "execute_command": "echo '' |  sudo -E -S sh ''"
},
{
  "type": "ansible-local",
  "playbook_file": "elasticsearch.yml",
  "extra_arguments": [
    "--module-path=./modules"
  ],
  "playbook_dir": "../../"
}
</code></pre>

<p>  ]
}</p>

<p>```</p>

<p>This is essentially a pretty simple script and builds an AWS Instance in a private subnet of my choice in eu-west-1a in AWS.</p>

<h4>install_dependencies.sh</h4>

<p>The first part of the script just installs the dependencies that my system has:</p>

<p>```</p>

<h1>!/bin/bash</h1>

<p>apt-get update
apt-get upgrade -y
apt-get install -y software-properties-common git
apt-add-repository -y ppa:ansible/ansible apt-get update</p>

<h1>workaround for ubuntu pip bug &ndash; <a href="https://bugs.launchpad.net/ubuntu/+source/python-pip/+bug/1306991">https://bugs.launchpad.net/ubuntu/+source/python-pip/+bug/1306991</a></h1>

<p>rm -rf /usr/local/lib/python2.7/dist-packages/requests
apt-get install -y python-dev</p>

<p>ssh-keyscan -H github.com > /etc/ssh/ssh_known_hosts</p>

<p>wget <a href="https://raw.github.com/pypa/pip/master/contrib/get-pip.py">https://raw.github.com/pypa/pip/master/contrib/get-pip.py</a>
python get-pip.py</p>

<p>pip install ansible paramiko PyYAML jinja2 httplib2 netifaces boto awscli six</p>

<p>```</p>

<h4>Ansible playbook for ElasticSearch</h4>

<p>The ElasticSearch playbook looks as follows:</p>

<p>```
&ndash; hosts: all
  sudo: yes</p>

<p>  pre_tasks:</p>

<pre><code>- ec2_tags:
- ec2_facts:
</code></pre>

<p>  roles:</p>

<pre><code>- base
- elasticsearch
</code></pre>

<p>```</p>

<p>The playbook installs a base role for all the base pieces of my system (e.g. Logstash, Sensu-client, prometheus node_exporter) and then proceeds to install ElasticSearch.</p>

<p>The ElasticSearch role looks as follows:</p>

<p>```
&ndash; ec2_facts:
&ndash; ec2_tags:</p>

<ul>
<li><p>name: Add Oracle Java Repository
apt_repository: repo=&lsquo;ppa:webupd8team/java&rsquo;</p></li>
<li><p>name: Accept Java 8 Licence
shell: echo oracle-java8-installer shared/accepted-oracle-license-v1-1 select true | tee /etc/oracle-java-8-licence-acceptance | /usr/bin/debconf-set-selections
args:
  creates: /etc/oracle-java-8-licence-acceptance</p></li>
<li><p>name: Add ElasticSearch repo public signing key
apt_key: id=46095ACC8548582C1A2699A9D27D666CD88E42B4 url=<a href="https://packages.elastic.co/GPG-KEY-elasticsearch">https://packages.elastic.co/GPG-KEY-elasticsearch</a> state=present</p></li>
<li><p>name: Add ElasticSearch repository
apt_repository:
  repo: &lsquo;deb <a href="http://packages.elasticsearch.org/elasticsearch/">http://packages.elasticsearch.org/elasticsearch/</a>/debian stable main&rsquo;
  state: present</p></li>
<li><p>name: Install Oracle Java 8
apt: name= state=latest
with_items:</p>

<ul>
<li>oracle-java8-installer</li>
<li>ca-certificates</li>
<li>oracle-java8-set-default</li>
</ul>
</li>
<li><p>name: Install ElasticSearch
apt: name=elasticsearch= state=present
notify: Restart elasticsearch</p></li>
<li><p>name: Copy /etc/default/elasticsearch
template: src=elasticsearch dest=/etc/default/elasticsearch
notify: Restart elasticsearch</p></li>
<li><p>name: Copy /etc/elasticsearch/elasticsearch.yml
template: src=elasticsearch.yml dest=/etc/elasticsearch/elasticsearch.yml
notify: Restart elasticsearch</p></li>
<li><p>name: Set elasticsearch service to start on boot
service: name=elasticsearch enabled=yes</p></li>
<li><p>name: Install plugins
command: bin/plugin &mdash;install 
args:
  chdir: &ldquo;&rdquo;
  creates: &ldquo;/plugins/&rdquo;
with_items: es_plugins
notify: Restart elasticsearch</p></li>
<li><p>name: Set elasticsearch to be running
service: name=elasticsearch state=running enabled=yes</p></li>
</ul>


<p>```</p>

<p>This is just some basic ansible commands to get the apt-repo, packages and plugins installed in the system. You can find the templates used <a href="https://gist.github.com/stack72/bdef4126ae8b08214bd8">here</a>. The important part to note is that variables are used both in the script <strong>and</strong> in the templates to setup the cluster to the required level.</p>

<p>My variables look as follows:</p>

<p><code>
es_release: "1.6"
es_version: ".0"
es_home: /usr/share/elasticsearch
es_wait_for_listen: yes
es_etc:
  cluster_name: central_logging_cluster
  discovery.type: ec2
  discovery.ec2.groups: elasticsearch-sg
  cloud.aws.region: ""
es_default_es_heap_size: 4g
es_plugins:
  - name: elasticsearch/elasticsearch-cloud-aws/2.6.0
  - name: elasticsearch/marvel/latest
  - name: mobz/elasticsearch-head
es_etc_index_number_of_replicas: 2
</code></p>

<p>As I have specified <code>elasticsearch-sg</code> and installed the <code>elasticsearch-cloud-aws</code> plugin, my nodes can auto-discover each other in the aws region. I can build the packer image as follows:</p>

<p>```</p>

<h1>!/bin/bash</h1>

<p>LATEST_UBUNTU_IMAGE=$(curl <a href="http://cloud-images.ubuntu.com/locator/ec2/releasesTable">http://cloud-images.ubuntu.com/locator/ec2/releasesTable</a> | grep eu-west-1 | grep trusty | grep amd64 | grep &ldquo;\"hvm:ebs\&rdquo;&ldquo; | awk -F &rdquo;[&lt;>]&ldquo; &lsquo;{print $3}&rsquo;)</p>

<p>packer build \
  -var ami_id=$LATEST_UBUNTU_IMAGE \
  -var security_group_id=MYSGID\
  -var private_subnet_id=MYSUBNETID \
  -var packer_build_number=PACKERBUILDNUMBER \
  elasticsearch.json</p>

<p>```</p>

<p>We are now ready to build the infrastructure for the cluster</p>

<h3>Building an ElasticSearch Cluster with Terraform</h3>

<p>The infrastructure of the ElasticSearch cluster is now pretty easy. I deploy my nodes into a <a href="https://aws.amazon.com/vpc/">VPC</a> and onto private subnets so that they are not externally accessible. I have an <a href="https://aws.amazon.com/elasticloadbalancing/">ELB</a> in place across the nodes so that I can easily get to the ElasticSearch plugins like <a href="https://www.elastic.co/guide/en/marvel/current/index.html">Marvel</a> and <a href="https://mobz.github.io/elasticsearch-head/">Head</a>.</p>

<p>The Terraform configuration is as follows:</p>

<p>```
resource &ldquo;aws_security_group&rdquo; &ldquo;elasticsearch&rdquo; {
  name = &ldquo;elasticsearch-sg&rdquo;
  description = &ldquo;ElasticSearch Security Group&rdquo;
  vpc_id = &ldquo;${aws_vpc.default.id}&rdquo;</p>

<p>  ingress {</p>

<pre><code>from_port = 9200
to_port   = 9400
protocol  = "tcp"
security_groups = ["${aws_security_group.elasticsearch_elb.id}"]
</code></pre>

<p>  }</p>

<p>  ingress {</p>

<pre><code>from_port = 9200
to_port   = 9400
protocol  = "tcp"
security_groups = ["${aws_security_group.node.id}"]
</code></pre>

<p>  }</p>

<p>  egress {</p>

<pre><code>from_port = "0"
to_port = "0"
protocol = "-1"
cidr_blocks = ["0.0.0.0/0"]
</code></pre>

<p>  }</p>

<p>  tags {</p>

<pre><code>Name = "ElasticSearch Node"
</code></pre>

<p>  }
}</p>

<p>resource &ldquo;aws_security_group&rdquo; &ldquo;elasticsearch_elb&rdquo; {
  name = &ldquo;elasticsearch-elb-sg&rdquo;
  description = &ldquo;ElasticSearch Elastic Load Balancer Security Group&rdquo;
  vpc_id = &ldquo;${aws_vpc.default.id}&rdquo;</p>

<p>  ingress {</p>

<pre><code>from_port = 9200
to_port   = 9200
protocol  = "tcp"
security_groups = ["${aws_security_group.node.id}"]
</code></pre>

<p>  }</p>

<p>  egress {</p>

<pre><code>from_port = "0"
to_port = "0"
protocol = "-1"
cidr_blocks = ["0.0.0.0/0"]
</code></pre>

<p>  }</p>

<p>  tags {</p>

<pre><code>Name = "ElasticSearch Load Balancer"
</code></pre>

<p>  }
}</p>

<p>resource &ldquo;aws_elb&rdquo; &ldquo;elasticsearch_elb&rdquo; {
  name = &ldquo;elasticsearch-elb&rdquo;
  subnets = [&ldquo;${aws_subnet.primary-private.id}&rdquo;,&ldquo;${aws_subnet.secondary-private.id}&rdquo;,&ldquo;${aws_subnet.tertiary-private.id}&rdquo;]
  security_groups = [&ldquo;${aws_security_group.elasticsearch_elb.id}&rdquo;]
  cross_zone_load_balancing = true
  connection_draining = true
  internal = true</p>

<p>  listener {</p>

<pre><code>instance_port      = 9200
instance_protocol  = "tcp"
lb_port            = 9200
lb_protocol        = "tcp"
</code></pre>

<p>  }</p>

<p>  health_check {</p>

<pre><code>healthy_threshold   = 2
unhealthy_threshold = 2
interval            = 10
target              = "TCP:9200"
timeout             = 5
</code></pre>

<p>  }
}</p>

<p>resource &ldquo;aws_autoscaling_group&rdquo; &ldquo;elasticsearch_autoscale_group&rdquo; {
  name = &ldquo;elasticsearch-autoscale-group&rdquo;
  availability_zones = [&ldquo;${aws_subnet.primary-private.availability_zone}&rdquo;,&ldquo;${aws_subnet.secondary-private.availability_zone}&rdquo;,&ldquo;${aws_subnet.tertiary-private.availability_zone}&rdquo;]
  vpc_zone_identifier = [&ldquo;${aws_subnet.primary-private.id}&rdquo;,&ldquo;${aws_subnet.secondary-private.id}&rdquo;,&ldquo;${aws_subnet.tertiary-private.id}&rdquo;]
  launch_configuration = &ldquo;${aws_launch_configuration.elasticsearch_launch_config.id}&rdquo;
  min_size = 3
  max_size = 100
  desired = 3
  health_check_grace_period = &ldquo;900&rdquo;
  health_check_type = &ldquo;EC2&rdquo;
  load_balancers = [&ldquo;${aws_elb.elasticsearch_elb.name}&rdquo;]</p>

<p>  tag {</p>

<pre><code>key = "Name"
value = "elasticsearch"
propagate_at_launch = true
</code></pre>

<p>  }</p>

<p>  tag {</p>

<pre><code>key = "role"
value = "elasticsearch"
propagate_at_launch = true
</code></pre>

<p>  }</p>

<p>  tag {</p>

<pre><code>key = "elb_name"
value = "${aws_elb.elasticsearch_elb.name}"
propagate_at_launch = true
</code></pre>

<p>  }</p>

<p>  tag {</p>

<pre><code>key = "elb_region"
value = "${var.aws_region}"
propagate_at_launch = true
</code></pre>

<p>  }
}</p>

<p>resource &ldquo;aws_launch_configuration&rdquo; &ldquo;elasticsearch_launch_config&rdquo; {
  image_id = &ldquo;${var.elasticsearch_ami_id}&rdquo;
  instance_type = &ldquo;${var.elasticsearch_instance_type}&rdquo;
  iam_instance_profile = &ldquo;app-server&rdquo;
  key_name = &ldquo;${aws_key_pair.terraform.key_name}&rdquo;
  security_groups = [&ldquo;${aws_security_group.elasticsearch.id}&rdquo;,&ldquo;${aws_security_group.node.id}&rdquo;]
  enable_monitoring = false</p>

<p>  lifecycle {</p>

<pre><code>create_before_destroy = true
</code></pre>

<p>  }</p>

<p>  root_block_device {</p>

<pre><code>volume_size = "${var.elasticsearch_volume_size}"
</code></pre>

<p>  }
}</p>

<p>```</p>

<p>This allows me to scale my system up or down just by changing the values in my Terraform configuration. When the instances are instantiatied, the ElasticSearch cloud plugin discovers the other members of the cluster and allows the node to join the cluster</p>
]]></content>
  </entry>
  
</feed>
